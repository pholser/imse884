LP background
=====
max z_LP = c^T * x
s.t. Ax <= b
     x >= 0

c, x in R^n
A in R^(m x n)
b in R^(m x 1)

Integer program:
max z_IP = c^T * x
s.t. Ax <= b
     x in Z^n_+   (x >= 0 and integer)

c in R^n
A in R^(m x n)
b in R^(m x 1)

Is there a relationship between z_LP and z_IP?
z_LP >= z_IP

In general, no poly-time algo to solve an IP.

Treat the LP as a linear relaxation of the IP
(remove the integrality restrictions).

e.g.
max 5x_1 + 2x_2
s.t. 3x_1 + x_2  <= 10
     2x_1 + 3x_2 <=  8
     x_1, x_2 >= 0 and integer

Linear relaxation:
max 5x_1 + 2x_2
s.t. 3x_1 + x_2  <= 10
     2x_1 + 3x_2 <=  8
     x_1, x_2 >= 0

Convex problems easy to solve; non-convex
problems not so much.

-- Convexity of function
    f(x) is convex
    <->
    forall x_1, x_2 in dom(f), forall lambda in [0, 1]:
        f(lambda * x_1 + (1 - lambda) * x_2)
        <=
        lambda * f(x_1) + (1 - lambda) * f(x_2)

-- Convexity of set
    S subset-of R^n is convex
    <->
    forall x_1, x_2 in S, forall lambda in [0, 1]:
        lambda * x_1 + (1 - lambda) * x_2 in S

-- feasible region of an LP is a convex set;
    IP not so much, unless:
    -- feasible region is a singular point
    -- feasible region is empty set

Can the linear relaxation of an IP be feasible,
but the IP infeasible?
--> max x_1 + x_2
    s.t. x_1 <= 1/2
         x_1 >= 1/4
    (linear relaxation unbounded here.)
--> narrow triangle that never contains integer points

Extreme points of feasible region of LP:
-- If there is an optimum, it's at a corner point
   -- As long as LP not infeasible or unbounded
-- Also called basic feasible solutions (BFS)

Degeneracy:
-- > 1 basis corresponding to a single BFS
-- One of the basic vars takes zero

Simplex method: move from corner to corner,
till optimum found.

e.g. max 5x_1 + 3x_2
     s.t. x_1 <= 4
          -x_1 + x_2 <= 6
          3x_1 + 2x_2 <= 18
          x_1, x_2 >= 0

z   x_1   x_2   s_1   s_2   s_3    RHS
--------------------------------------
1    -5    -3     0     0     0      0
0     1     0     1     0     0      4  s_1
0    -1     1     0     1     0      6  s_2
0     3     2     0     0     1     18  s_3

x_1 leaves
s_1 enters: 4/1 min

z   x_1   x_2   s_1   s_2   s_3    RHS
--------------------------------------
1     0    -3     5     0     0     20
0     1     0     1     0     0      4  x_1
0     0     1     1     1     0     10  s_2
0     0     2    -3     0     1      6  s_3

x_2 leaves
s_3 enters: 6/2 min

z   x_1   x_2   s_1   s_2   s_3    RHS
--------------------------------------
1     0     0    1/2    0   3/2     29
0     1     0     1     0     0      4  x_1
0     0     0    5/2    1   -1/2     7  s_2
0     0     1   -3/2    0    1/2     3  x_2

z* = 29, x_1 = 4, x_2 = 3, s_2 = 3/2, s_1 = 0, s_3 = 0

If this were an IP, and we ended up with a non-integer
soln, we'd need to cut the space down.

Add a constraint: x_1 + x_2 <= 5
Re-solve as LP
Add constraint to tableau
Re-establish basis...
Check optimal; if not, pivot, maybe dual simplex


Duality in LP
=====

primal:
e.g.
max c^T * x
s.t. Ax <= b
     x >= 0

dual:
min b^T * y
s.t. A^T * y >= c
    y >= 0

c^T * x <= b^T * y   # weak duality

If there is an optimum to the primal,
there is an optimum to the dual, and
    c^T * x^* = b^T * y^*

Complementary slackness:
For a corner-point soln:
If x_i is basic, e_i is non-basic
    (e = surplus var)
If s_i is basic, y_i is non-basic
    (s = slack var)

    x * e = 0
    s * y = 0

Reduced costs/shadow prices/dual prices: values in
objective row of simplex tableau above the slacks

Sensitivity analysis

Better off with simplex method on linear relaxations
of IP, as opposed to interior-point methods
(why?)

Simplex may require exponential time in pathological
cases.
There are polynomial-time algos for LP now
(interior-point methods)

if A then B:
T     T   -->  T
T     F   -->  F
F     T   -->  T
F     F   -->  T

A iff B:
T     T   -->  T
T     F   -->  F
F     T   -->  F
F     F   -->  T

Proof by contradiction of "if A then B":
-- Assume A is true; assume B is false.
-- What follows from this? Need to show that
    this leads to a contradiction, and so B
    must be true

Contrapositive: if not B, then not A
Converse: if B, then A
Inverse: if not A, then not B


Graph: set G = (V, E)
V = vertices, E = edges

Directed edges or undirected edges

Graph as substructure for building an IP

Node-node adjacency matrix representation
(A[x, y] = 1 if nodes x and y are connected via
an edge, else ___? (sometimes 0, sometimes -(degree)))

   A   B   C   D
A  0   1
B  1   0
C          0
D              0

(symmetric for undirected graph)

Node-arc incidence matrix:
    (A,B) (A,C) ...
A
B
C
C

Exactly two ones in every column
Usually more edges than nodes -> more storage req'd

Directed node-arc rep:
 1 for flow-out
-1 for flow-in
All columns sum to zero --> unimodular matrix
-- not linearly independent
    --> cross off bottom row
        --> basis: tree (graph w/no cycles)
            fast pivots (network simplex method)
-- If this is only set of constraints, and RHS
    of constraints are integers, then you'll get
    an integer soln always

Paths

Discovered tree

Clique of a graph: subgraph that has all possible
edges (every node has an edge to every other node)
-- k_n, where n is # of nodes in clique
(complete graph)
# edges: C(n, 2)

Complement of a graph:
graph with same set of vertices, but with edges
where there weren't edges in original graph, and
the original edges removed.

Bipartite graph:
where vertices are partitioned into two sets, and
there are no edges between two nodes in the same
partition.
These come up in transportation models a lot--
-- sources vs. destinations
-- assignment problems: tasks to workers...
-- no odd cycles

Matching problem:
-- sum[i]( x_ij ) <= 1 forall j
-- sum[j]( x_ij ) <= 1 forall i

Node packing problem:
find a set of nodes of maximum cardinality such that
no node is incident with the same edge (or arc)

Set packing problem:
Given a universe U and a family S of subsets of U,
find a collection C of sets in S, whose cardinality is
maximized, such that all sets in C are pairwise
disjoint.

O(f(n)), Omega(f(n)), Theta(f(n))
Polynomial-in-n time

Implicit enumeration of binary IP solutions:
exponential in # vars

NP: set of all problems whose solutions can be verified
in polynomial time
NP-complete: set of NP problems that can be transformed
into each other in polynomial time.
NP-hard: at least as hard as the hardest problems in NP
(don't have to be elements of NP)

IP are NP-complete problems



































.
